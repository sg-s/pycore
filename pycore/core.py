"""
This module contains core functionality that is present in MATLAB
but isn't in python, so acts as a shorthand for commonly used functions
and types 
"""
import matplotlib.pyplot as plt
import numpy as np
import inspect
import os

import matplotlib.transforms as mtransforms


def methods_and_properties(thing, ignore_internal=True):
    """returns methods and properties of an object

    Args:
        thing (object): some object

    Returns:
        methods: list of method names
        properties: list of property names

    """

    method_list = []
    prop_list = []
    for attr_name in dir(thing):

        if attr_name.startswith("_") and ignore_internal:
            continue

        try:
            if callable(getattr(thing, attr_name)):
                method_list.append(str(attr_name))
            else:
                prop_list.append(str(attr_name))
        except:
            pass

    return method_list, prop_list


def methods(thing, spacing=20, ignore_internal=True):
    """show methods of object.

    Args:
        thing (some object): any object

    Ignores attributes starting with "__"

    modified from: https://stackoverflow.com/questions/34439/finding-what-methods-a-python-object-has

    """

    method_list, _ = methods_and_properties(thing, ignore_internal=ignore_internal)

    process_func = (lambda s: ' '.join(s.split())) or (lambda s: s)

    for method in method_list:

        try:
            print(
                str(method.ljust(spacing))
                + ' '
                + process_func(str(getattr(thing, method).__doc__)[0:90])
            )
        except:
            print(method.ljust(spacing) + ' ' + ' getattr() failed')


def properties(thing, ignore_internal=True, spacing=20):
    """show properties of object

    Args:
        thing (TYPE): object
        ignore_internal (True, optional): should we ignore attrs that start with _?
    """
    _, prop_list = methods_and_properties(thing, ignore_internal=ignore_internal)

    process_func = (lambda s: ' '.join(s.split())) or (lambda s: s)

    for method in prop_list:

        try:
            print(
                str(method.ljust(spacing))
                + ' '
                + process_func(str(getattr(thing, method).__doc__)[0:90])
            )
        except:
            print(method.ljust(spacing) + ' ' + ' getattr() failed')


def labelled_subplots(mosaic, label=True, **optionals):
    """wrapper to subplot_mosaic that makes subplots

    Args:
        mosaic (list of lists): or other mosaic compatible arg.
        **optionals: key value arguments that are passed onto subplot_mosaic

    Returns:
        fig: handle to figure
        axes: numpy array of axes
    """
    plt.close('all')
    fig, axes = plt.subplot_mosaic(mosaic, constrained_layout=True, **optionals)
    if label:
        label_axes(fig, axes)

    axes = dict_to_array(axes)

    return fig, axes


def label_axes(fig, axs, fontsize=15):
    """label axes generated by subplot_mosaic

    given a dictionary of axes objects, each axes object is labelled
    with the key of that dictionary item

    Args:
        fig (matplotlib.figure.Figure):
        axs (dictionary of axes):
        fontsize (str, optional): specify font size using valid syntax
    """
    for label, ax in axs.items():
        # label physical distance to the left and up:
        trans = mtransforms.ScaledTranslation(-20 / 72, 7 / 72, fig.dpi_scale_trans)
        ax.text(
            -0.02,
            1.0,
            label,
            transform=ax.transAxes + trans,
            fontsize=fontsize,
            va='bottom',
            fontfamily='sans-serif',
            fontweight='bold',
        )


def check_element_type(things, typename):
    """checks if a numpy array has elements of a certain type

    Args:
        things (np.ndarray): array that should contain typename
    """

    check_type(things, np.ndarray)
    for thing in things:
        check_type(thing, typename)


def check_vector(thing):
    """checks if argument is a numpy vector

    Args:
        thing (anything): any thing

    Returns:
        nothing
    """

    check_type(thing, np.ndarray)

    assert (
        len(thing.shape) == 1
    ), "Argument is not a numpy.vector, instead, it has shape: " + str(thing.shape)


def dict_to_array(d):
    """converts d to an np.array, ignoring keys

    Args:
        d (dictionary): some dictionary
    """

    temp = np.array(list(d.items()))
    return temp[:, -1]


def check_first_dimension_size(things):
    """checks if all the things passed in here have the same
    size in the first dimension

    Args:
        things (tuple): tuple of anything
    """

    if hasattr(things[0], 'shape'):
        first_dim_size = things[0].shape[0]
    else:
        first_dim_size = len(things[0])

    for thing in things:
        if hasattr(thing, 'shape'):
            this_size = thing.shape[0]
        else:
            this_size = len(thing)

        assert (
            first_dim_size == this_size
        ), "Not all things have the same first dimension size"


def splitapply(data, groups, func=np.nanmean, flatten=False):
    """equivalent to MATLAB's splitapply

    Args:
        data (np.ndarray): 2D or 1D matrix
        groups (np.ndarray): vector as long as data

    Returns:
        result: np.ndarray the same size as unique(groups)
        unique_values: unique values in groups
    """

    check_type(data, np.ndarray)
    check_type(groups, np.ndarray)
    check_first_dimension_size((data, groups))

    data = np.copy(data)

    unique_values = np.unique(groups)

    if flatten or len(data.shape) == 1:
        result = np.full_like(unique_values, np.nan)
    else:
        result = np.zeros((unique_values.shape[0], data.shape[1]))

    for i, value in enumerate(unique_values):
        this = data[groups == value]

        if flatten:
            result[i] = func(data[groups == value].flatten())
        else:
            result[i] = func(data[groups == value])

    return result, unique_values


def Vector(N, dtype='float64', fill=None):
    """makes a vector, because this is fraught with danger

    Args:
        N (int): how long should it be?
        dtype (str, optional): type of thing in vector
        fill (None, optional): What should it be filled with?

    Returns:
        TYPE: Description
    """
    x = np.zeros(N, dtype=dtype)
    if fill is not None:
        x.fill(fill)
    else:
        x.fill(np.nan)

    return x


def StringArray(N, value=""):
    """make a 1D string array

    I can't see any built-in which makes an array of strings
    Lists don't work because they don't enforce type and will
    therefore be inefficient.
    This is the equivalent of repmat("",N,1) in MATLAB

    Args:
        N (integer): length of array
        value (optional): fill array with this value
    """
    array = np.array([value for _ in range(N)], dtype='<U5')
    return array


def NaN(dims):
    """makes a NaN array. like NaN in MATLAB

    Args:
        dims (TYPE): tuple specifying shape

    Returns:
        TYPE: array filled with NaNs
    """
    array = np.empty(dims)
    array.fill(np.nan)
    return array


def check_axis(axis):

    '''
    Utility function that generates an axis if needed, and activates it

    Parameters:
    -----------
    axis: None or axis

    Returns:
    -----------
    handle to an axis

    '''

    if axis is None:
        _, axis = plt.subplots()

    plt.sca(axis)
    return axis


def imshow(X, axis=None):
    """behaves like MATLAB's imshow, just plots the matrix given to it

    If no axis is specified, returns a handle to the axis. If it is,
    then returns a handle to the image


    Arguments:
        X (np.ndarray): Description
        axis (None, optional): where to plot?

    Returns:
        axis: handle to an axis
        or
        image_handle: handle to image created on axis provided
    """

    check_type(X, np.ndarray)

    return_axis = False
    if axis is None:
        return_axis = True

    axis = check_axis(axis)
    axis.imshow(X, aspect='auto')

    image_handle = axis.get_images()

    if return_axis:
        return axis
    else:
        return image_handle


def check_type(thing, typename):
    """
    checks if thing is of type typename, if not, throws an error

    Arguments:
    ----------
    thing: any object
    typename: valid python type of type type
    """

    assert isinstance(thing, typename), (
        "Expected argument to be of: "
        + str(typename)
        + ". Instead, it was of: "
        + str(type(thing))
    )
